// двумерные массивы
/*
это таблица или матрица, массив массивов. массив имеет имя, поиск в нем с помощью индексации. 
чтобы обратиться к нужному элементу в двумерном массиве мы указываем в квадратных скобках сначала номер строки , затем номер столбца
table [1] [3] - имя массива table, [1] это номер строки,  [3] это номер столбца или индекц элемента, соответствующий номеру к одномерном массиве
матрица это математический объект, который записывается в форме таблицы, которая представляет собой количество строк и столбцов, на пересечении которых находятся элементы матрицы. их можно складывать, перемножать и вычислять их данные.

// задачи на использование двумерных массивов

// создать двумерный массив размером 3х5 из целых чисел, вывести элементы на экран
// 1) укажем тип данных int [,] -то есть в скобках ставим запятую, чтобы для программы стала понятна размерность и тип массива. первое число в массиве указывает на строку, второй (после запятой) указывает на столбец 
//2) указываем имя массива table
//3) выделяем память для нового массива new int[3, 5] - указываем сначала количество строк первым числом, вторым указываем количество элементов в строках

int[,] matrix = new int[3, 5]; // создаем двумерный массив с целочисленным типом данных, именем matrix; new int [3, 5] это команда для создания нового массива с тремя строками и пятью элементами в каждой строке
// необходимо пройтись по массиву и заполнить его числами. в одномерном массиве можно заполнить его с помощью цикла for, пройтись по всем элементам массива и заполнить их. в двумерном массиве- сначала нужно пройти по его одномерным массивам, то есть по строкам, и затем заполнить эти строки.
// для заполнения двумерного массива необходимы два цикла- первый нужен для прохода по СТРОКАМ, по одномерным массивам; второй цикл нужен для прохода по ЭЛЕМЕНТАМ каждого массива
Random rnd = new Random();
// создаем первый цикл for для прохода по строкам массива
for (int i = 0; i < matrix.GetLength(0); i++) // int i это переменная цикла счетчика, равна нулю(то есть пустая); далее необходимо указать количество строк в массиве, используем соответсвующее свойство  matrix.GetLength(0) - это свойство позволяет нам вычислить количество строк и столбцов.есл мы указываем нулевое измерение, это значит что бы требуем запросить количество строк в двумерном массиве; i++ это переход к следующему элементу
// данный цикл позволит нам обратиться к очередному одномерному массиву. внутри этого цикла сформируем второй цикл,который осуществит обращение к элементам одномерного массива
{
    for (int j = 0; j < matrix.GetLength(1); j++) // укажем индекс j, поскольку i уже занята в цикле; дальше обращаемся к количеству элементов в массиве командой matrix.GetLength(1); где в скобках указываем 1, чтобы запросить количество столбцов в этом массиве 
    { // на этом этапе мы можем обратиться к элементам массива с помощью имени matrix и индекса [] строки i и столбца j 
      // заполним массив случайными числами. для этого создадим обьект Random и выделим под него память 
      // Random rnd = new Random(); // переменная рандома
        matrix[i, j] = rnd.Next(1, 11); // присваиваем значениям матрицы случайные значения из обьекта рандома
                                        // объект Random создается при каждом обращении к элементам массива, то есть если элементов 15 в массиве, то объект Random создается 15 раз
                                        // осуществление 15 циклов создания рандома энергозатратно, поэтому его лучше вынести за циклы
    }
}
// выведем заполненный массив на экран. как для заполнения, так и для вывода, нам нужно перебрать все элементы массива
// воспользуемся для этого таким же циклом for 
{
    for (int i = 0; i < matrix.GetLength(0); i++) // проходимся по элементам массива
    {
        for (int j = 0; j < matrix.GetLength(1); j++) // проходимся по элементам массива
        {
            Console.Write($"{matrix[i, j]} "); // этот метод ($"{matrix [i, j]} "); называется интерполяция строк
        } 

         Console.WriteLine();
    }
    // Console.WriteLine();
}
*/
// работает. сейчас буду сама создавать и выводить массив на экран.

/*
int[,] matrix = new int[10, 10]; // создаем двумерный массив, в параметре  new int задаем размер массива
Random rand = new Random(); // задаем объект рандом, который заполнит наш массив случайными числами
{
    for (int i = 0; i < matrix.GetLength(0); i++)
    {
        for (int j = 0; j < matrix.GetLength(1); j++)
        {
            matrix[i, j] = rand.Next(1, 100);
        }
        // Console.WriteLine();
    }
    
} // заполнили массив числами

for (int i = 0; i < matrix.GetLength(0); i++)
{
    for (int j = 0; j < matrix.GetLength(1); j++)
    {
        Console.Write($"{matrix[i, j]} ");
    }
    Console.WriteLine();
} // вывела массив на экран
Console.WriteLine("вторая попытка создания массива без подсказок");


int[,] second = new int[5, 3];
Random randi = new Random();
{
    for (int i = 0; i < second.GetLength(0); i++)
    {
        for (int j = 0; j < second.GetLength(1); j++)
        {
            second[i, j] = randi.Next(20, 90);
        }
    }
} // заполнила массив числами

for (int i = 0; i < second.GetLength(0); i++)
{
    for (int j = 0; j < second.GetLength(1); j++)
{
    Console.Write($"{second[i, j]} ");
}
Console.WriteLine();
}
Console.WriteLine("третья попытка понять принцип");


int[,] table = new int[5, 3];
Random rend = new Random();
{
for (int i = 0; i < table.GetLength(0); i++)
{
for (int j = 0; j < table.GetLength(1); j++)
{
    table[i, j] = rend.Next(2, 5);
} 
}
}

for (int i = 0; i < table.GetLength(0); i++)
{
    for (int j = 0; j < table.GetLength(1); j++)
    {
        Console.Write($"{table[i, j]} ");
    }
    Console.WriteLine("поняла))))))");
}
*/



// создаем функции по предыдущему коду
// функции заполнение массива и вывод на экран

// функция, которая сгенерирует двумерный массив из случайных целых чисел
//1. что будет делать функция? она будет ВЫДЕЛЯТЬ ПАМЯТЬ для массива некоторого размера и заполнит его целыми числами
//2. какие данные ей1 понадобятся? для выделения участка памяти необходимо знать его размер. то есть для массива в виде строк и столбцов в функцию нужно передать в качестве параметров
//3. что будет возвращать функия? функция будет возвращать двумерный массив, его можно вернуть в качестве возвращаемого значения
// int[,] matrix = new int[4, 4]; // наш массив, с которым будем работать 
//Random rand = new Random(); // объект случайных чисел
//укажем тип возвращаемого значения - двумерный целочисленный массив, далее имя функии и ее параметры- их два параметра- количество строк(int row) и количество столбцов (int colums)
/*
int[,] CreateMat(int rowCount, int columsCount) // row и colums нам понадобятся для создания размера массива
{
    int[,] matrix = new int[rowCount, columsCount];
    Random rand = new Random();
    for (int i = 0; i < matrix.GetLength(0); i++)
    {
        for (int j = 0; j < matrix.GetLength(1); j++)
        {
            matrix[i, j] = rand.Next(20, 50);
        }
    }
    return matrix; // поскольку функция имеет возвращаемый тип, просим ее ВЕРНУТЬ созданный и заполненный новый массив
}

// код для выведения функции на экран, тоже оформляем в виде функции
// функция, которая что то выводит на экран, не возвращаемая, то есть ее метод void
void PrintMatrix(int[,] matrix) // тип данных void, имя функции PrintMatrix, переданный параметр массив int[,] matrix, который необходимо напечатать
{
    for (int i = 0; i < matrix.GetLength(0); i++)
    {
        for (int j = 0; j < matrix.GetLength(1); j++)
        {
            Console.Write($"{matrix[i, j]} ");
        }
        Console.WriteLine();
    }

}

// проверим работоспособность функции
// создадим массив mat и в него передадим функцию CreateMat. в CreateMat в скобках укажем (передадим параметры) количество строк и столбцов
int[,] mat = CreateMat (2, 10); // показатели в скобках можно менять и создавать разного размера двумерные массивы
// затем выведем массив на экран, воспользуемся функцией PrintMatrix и передадим ей вышесозданный массив в котором хранятся данные из функции создания массива

PrintMatrix(mat); // работает
*/
// теперь создам функции сама
/*
int[,] CreateArray(int col, int mol) // в параметры передаем тип int, потому что в вызове функции принимает целое число, а не массив!!!!!!!
{
    int[,] table = new int[col, mol];
    Random m = new Random();
    {
        for (int i = 0; i < table.GetLength(0); i++)
        {
            for (int j = 0; j < table.GetLength(1); j++)
            {
                table[i,j] = m.Next(100, 1000);
            } 
        }
        return table; 
    } 
}

void PrintAr ( int[,] table)
{
    for (int i = 0; i < table.GetLength(0); i++)
    {
        for (int j = 0; j < table.GetLength(1); j++)
        {
            Console.Write($" {table[i, j]} ");
        }
        Console.WriteLine();
    }

    //Console.WriteLine();
}

int[,] a = CreateArray(5, 9);
PrintAr(a);

*/

// еще раз напишу, чтобы запомнить. работает
/*

using System.Runtime.InteropServices;

int[,] MakeAr (int a, int b)
{
  int[,] c = new int [a, b];
  Random d = new Random();
  {
    for (int i = 0; i < c.GetLength(0); i++)
    {
        for (int j = 0; j < c.GetLength(1); j++)
        {
            c[i, j] = d.Next(1, 3);
        }
    }
  }
  return c;
}

void PrintA (int[,] c)
{
    for (int i = 0; i < c.GetLength(0); i++)
    {
        for (int j = 0; j < c.GetLength(1); j++)
        {
            Console.Write($"{c[i, j]} ");
        }
        Console.WriteLine();
    }
    // Console.Write(" ");
}

int[,] e = MakeAr (4, 5);
PrintA(e);
*/
// Console.Clear();
// разные способы создания двумерных массивов
// при создании массива сразу указывать данные
/*
int[,] mas = new int[5, 4] {
{1, 2, 3, 4},
{5, 6, 7, 8},
{9, 10, 11, 12},
{13, 14, 15, 16},
{17, 18, 19, 20},
};
{
    for (int i = 0; i < mas.GetLength(0); i++)
    {
        for (int j = 0; j < mas.GetLength(1); j++)
        {
            Console.Write($"{mas[i, j]} ");
        }
        Console.WriteLine(); // просим вывести массив после первого цикла прохождения 
    }
     Console.WriteLine();
}

// при указании параметров массива можно его размеры не указывать, если они извнстны
int[,] max = new int[,] 
{
    {1, 2, 3},
    {4, 5, 6} // в самом массив при указании параетров ; ставить не надо, только б
};
{
    for (int i = 0; i < max.GetLength(0); i++)
    {
        for (int j = 0; j < max.GetLength(1); j++)
        {
            Console.Write($"{max[i,j]} ");
        }
        Console.WriteLine();
    }
}
Console.WriteLine(" ");

// самый компактный способ задать массив без указания оператора выделения памяти
int[,] min = {
    {10, 20, 30},
    {40, 50, 60},
    {70, 80, 90}
};
{
    for (int i = 0; i < min.GetLength(0); i++)
    {
        for (int j = 0; j < min.GetLength(1); j++)
        {
            Console.Write($"{min[i,j]} ");
        }
        Console.WriteLine();
    } 
}
*/

// создание двумерного массива из целых чисел. вывести на экран числа, сумма цифр которых четная
/*
1) создать массив, заполнить его целыми числами. получилось
2) пройтись по всем элементам массива. получается
3) взятие очередного элемента 
- проверить сумму чисел в элементе
- проверить, делится ли сумма на 2 без остатка (проверка на четность)
4) вывесли на экран числа, сумма которых четная.
*/
//Console.Clear();
/*
int[,] FillArray(int a, int b)
{
    int[,] arr = new int[a, b];
    Random r = new Random();
    for (int i = 0; i < arr.GetLength(0); i++)
    {
        for (int j = 0; j < arr.GetLength(1); j++)
        {
            arr[i, j] = r.Next(10, 100);
        }
    }
    return arr;
}

void PrintArray(int[,] arr)
{
    for (int i = 0; i < arr.GetLength(0); i++)
    {
        for (int j = 0; j < arr.GetLength(1); j++)
        {
            Console.Write($"{arr[i, j]} ");
        }
        Console.WriteLine();
    }
}


int[,] c = FillArray(4, 9); // здесь хранится созданный массив
PrintArray(c);

foreach (int e in c)

{
    if (IfInteresting(e) == true)
    {
        Console.Write($"{e} ");
    }
     Console.Write("");
   
}
Console.WriteLine();


bool IfInteresting(int value)
{
    int SumOfDig = GetSum(value);
    if (SumOfDig % 2 == 0)
    {
        return true;
    }
    return false;
}

int GetSum (int value)
{
    int sum = 0;
    while (value > 0)
    {
        sum = sum + value % 10;
        value = value / 10;
    }
    return sum;
}

//PrintArray(c); // эта функция выводит созданный массив
// программа работает
*/


// еще раз напишу эту задачу
//using System.Diagnostics.CodeAnalysis;
//using System.Dynamic;
// using System.Runtime.CompilerServices;

//Console.Clear();

//int[,] CreateA (int a, int b); // функция заполнения массива рандомными числами
/*
  int[,] FillArray(int a, int b) 

{
   int[,] arr = new int[a, b]; // int[,] arr = new int[a, b];
   Random r = new Random(); // Random rand = new Random();
   for (int i = 0; i < arr.GetLength(0); i++)
   {
       for (int j = 0; j < arr.GetLength(1); j++)
       {
           arr[i, j] = r.Next(10, 100);
       }
   }
   return arr;
} 


   void PrintA (int[,] arr) // печать массива на экран
   {
       for (int i = 0; i < arr.GetLength(0); i++)
       {
           for (int j = 0; j < arr.GetLength(1); j++)
           {
               Console.Write($"{arr[i, j]} ");
           }
       Console.WriteLine();
   }
   }


int[,] d = FillArray(5, 6);
PrintA(d);

*/

// функция создания массива с заполнением его рандомными числами
// решение задачи: задать массив и вывести на экран числа с четной суммой цифр в числе
/*
int[,] FillA (int a, int b)
{
    int[,] arr = new int[a, b];
    Random coc = new Random();
    for (int i = 0; i < arr.GetLength(0); i++)
    {
        for (int j = 0; j < arr.GetLength(1); j++)
        {
            arr[i, j] = coc.Next(10, 1000);
        }
    } return arr;
}
void PrintA (int[,] arr) // печать массива на экран
    {
        for (int i = 0; i < arr.GetLength(0); i++)
        {
            for (int j = 0; j < arr.GetLength(1); j++)
            {
                Console.Write($"{arr[i, j]} ");
            }
        Console.WriteLine();
    }
    }

int[,] matrix = FillA(4, 3);
PrintA(matrix);

// foreach проходит по массиву и ищет интересные числа (в этой задаче ищет четную сумму чисел)
foreach (int e in matrix)
{
    if (IsInt (e) == true) // IsInt функция проверки суммы на четность, (е) это переменная цикла форич
    {
        Console.Write($"{e} "); // если сумма чисел четная, число из массива записывается в переменную е и выводится число!! на экран
    }
    //Console.WriteLine(" ");
}


// value это одно целое число из массива
bool IsInt (int value) // функция bool будет возвращать true/ false, если в ее теле сумма чисел четная, она вернет true, если нечетная, то ничего не вернет. на вход эта функция принимает перемнную value, то есть одно целое число из массива и с ним работает
{ // переменная sum хранит в себе сумму цифр в числе, то есть результат работы функции GetSum
    int sum = GetSum(value); // GetSum это имя функции, в которой  будет происходить вычисление суммы
 // порверим четность суммы
  if (sum % 2 == 0)
  {
    return true;
  }
   return false;

}

// пишем функцию по подсчету суммы цифр

int GetSum (int value)
{
// переменная содержит в себе сумму цифр в числе
int sum1 = 0;
while(value < 0) // работа цикла продолжается, пока число из массива больше нуля
{
    sum1 = sum1 + value % 10; // здесь в переменную сум1 сохраняем результат деления числа из массива на 10 без остатка, то есть вычисляем первую цифру в числе
    // чтобы перейти к следующей цифре, делим получившееся число на 10
    value = value / 10; // то есть в этом цикле мы  "отрезали" одну цифру от числа справа
}
// по результату работы функции вернем ответ
return sum1;
}











/*
// функция печати массив на экран
 void PrintA (int[,] arr)
 {
    for (int i = 0; i < arr.GetLength(0); i++)
    {
        for (int j = 0; j < arr.GetLength(1); j++) 
        {                                           //
            Console.Write($"{arr[i, j]} ");         //
        }                                           //
        Console.WriteLine();                        // 
    }                                               // этот порядок строк выводит квадратный массив 
     
 }


//int[,] c = FillA(4, 6);
//PrintA(c);
// сплошные мучения!!!!
*/







// строки в массиве
// строка это последовательный набор символов, который используют для представления текста
// строка в С# это массив символов типа char. для работы со строками используется тип string 
// доступ к элементам строки можно осуществить с помощью индексации, то есть зная порядковый номер элемента, можем к нему обратиться
// пример: 

//string str = "Hello world!";
//Console.Write(str[6]); // работает

// строка это неизменяемый тип данных, элементы строки не могут быть изменены, размер строки тоже не может быть изменен
// для вывода конкретного элемента в массиве типа char так же используют обращение к элементу с указанием переменной и индексом в []
//Console.WriteLine(string[1]); // ok
// способы создания строки в С#
/*
1) присвоение переменной строкового литерала
string s1 = "hello";
2)  создание строки из массива символьного типа char. для этого нужно создать массив символов, далее с указанием оператора new и типа данных string создаем строку на основании переданного символьного массива
 char[] ch_array = { 'w', 'o', 'r', 'l', 'd'};
 string s2 = new String (ch_array);
  // в этом случае String используется как конструктор строки (конструктор это метод, который создает обьект)
3)используется для строк из повторяющихся символов
string s3 = new String('a', 6); // указываем нужный один символ и его количество


Тип данных String предоставляет набор методов, которые требуются для обрабокт строк:
1) метод Contains определяет, содержится ли подстрока в строке. используют для поиска какого либо слова в тексте
2) метод EndsWith определяет, совпадает ли конец строки с подстрокой (оканчивается ли какая нибудь строка каким либо словом). используют при проверке расширения файлов
3) метод IndexOf находит индекс первого вхожддения символа или подстроки в строке
4) метод Insert вставляет в строку подстроку
5) метод Replace замещает в строке символ или подстроку другим символом или подстрокой, используют при работе с текстом, если нужно заменить слово или символ на другой

методы Insert Replace используют для внесения изменений в текст, их особенность в том, что при своей работе эти методы создают новую строку (выделяют новый фрагмент в памяти) и результаты функций Insert и Replace помещают в новую строку . то есть исходная строка не изменяется,а результаты формируются в новой строке 

*/

// задача: считать с консоли строку, состоящую из латинских букв и цифр. Сформировать новую строку, состоящую из букв исходной строки
// 1. ввод строки с консоли
// 2. проход по элементам строки и выявить буквы в циклах for / foreach
// 3. каждый элемент будем проверять, является ли он буквенным символом 
// 4. дописать подходящий элемент к новой строке
/*
string GetLetters (string s)
{
    string letters = "";
    foreach(char e in s)
    { // метод IsAsciiLetter проверяет в своей таблице символы, цифры и буквы на присутсвие в своих данных
        if(Char.IsAsciiLetter(e) == true)
        {
            letters = letters + e; // приписываем символ Е к строке Letters
        }

    }
    return letters;
}
// функцияпо поиску буквенных символов в заданной строке

// создаем строковую переменную и помещаем в нее значение, считанное из консоли
string str = Console.ReadLine();
// запустим созданную функцию с параметром str
string result = GetLetters(str); // переменная для выведения результата на экран, в ней хранится результат функции поиска нужных элементов в строковом массиве
Console.WriteLine(result);
// работает
*/

// операторы управления break и continue
// передача управления это переход вовремя выполнения программы на другой участок кода 
// Break это прерывание выполнения ближайшего внещнего цикла (while, for, foreach)
// break испольнуют, когда возникло условие, при котором цикл нужно немедленно прервать
// например если запущен цикл с условием true- то выйти из него сможем с оператором return или оператором break (while это бесконечный цикл)
// while (true)
//{
//Console.WriteLine("im in the loop!");
//break;
//}

// задача: выдать на экран сообщение в случае наличия в массиве нечетного числа
/*
 Console.WriteLine("Start");

 int[] numbers = {2, 4, 6, 7, 8, 10};
 foreach (int e in numbers)
 {
   if (e % 2 == 1)
   {
       Console.WriteLine("There is odd number");
       break;
   }
 }
 Console.WriteLine("stop"); // работает
 */

// задача: сообщить о наличии отрицательных элементах в строках двумерного массива
/*
int[,] table = { {1, 1, 1},
                 {2, -2, 2},
                 {3, 3, -3} };

for (int i = 0; i < table.GetLength(0); i++)
{
    for (int j = 0; j < table.GetLength(1); j++)
    {
        if (table[i,j] < 0)
        {
            Console.WriteLine($" отрицательный элемент в строке {i}");
            break;
        }
    }
}
// работает
*/

// второй оператор передачи упарвления continue 
// начинает новую итерацию ближайшего внешнего цикла (while, for, foreach). используют, когда возникло условие, при котором оставшиеся инструкции тела цикла нужно пропустить
/*
for (int i = 0; i <= 5; i++)
{
    Console.Write($"итерация {i}: ");
    if (i = 3) // третью итерацию нужно пропустить и передать сообщение в консоль
    {
        Console.WriteLine("skip");
        continue;
    }
    Console.WriteLine("что то происходит");
}
*/

/*
теория
1.двумерный массив это таблица или представляет  собой совокупность (некоторе количество) одномерных массивов, это количество однотипных данных, хранящихся в одном месте
2. двумерный массив хранится в памяти как одномерный массив с однотипными данными , данные идуд друг за другом в строку, не пропуская ячеек памяти
*/




//Тело класса будет написано студентом. Класс обязан иметь статический метод PrintResult()
// class UserInputToCompileForTest


/// Вычисление сумм по строкам (на выходе массив с суммами строк)
int SumRowArray(int[,] array)
    { 
        int[,] numbers = new int[,] {
    {1, 2, 3},
    {1, 1, 0},
    {7, 8, 2},
    {9, 10, 11}
};
     int[] sumArr = new int[array.GetLength(0)];
  // Console.WriteLine($"Сумма по строке:");
  for (int i = 0; i < array.GetLength(0); i++)
  {
    for (int j = 0; j < array.GetLength(1); j++)
    {
      sumArr[i] += array[i, j];
    }
   // Console.WriteLine($"{i + 1} -> {sumArr[i]}");
  }
  int minSum = sumArr[0];
  int minRow = 1;
  for (int i = 0; i < array.GetLength(0); i++)
  {
    if (sumArr[i] < minSum)
    {
      minSum = sumArr[i];
      minRow = i + 1;
    }
  }
  return minRow;
}//return minRow;

// Получение индекса минимального элемента в одномерном массиве
      
      
 int MinIndex(int[] numbers)
{
    //Напишите свое решение здесь
    int min = SumRowArray; 
    {
    Console.WriteLine(min);
    }
}



void PrintResult(int[,] numbers)
{
    //Напишите свое решение здесь
    int s = 
    {
    Console.WriteLine(s);
    }
}


//Не удаляйте и не меняйте класс Answer!
class Answer
{
    public static void Main(string[] args)
    {
        int[,] numbers;

        if (args.Length >= 1)
        {
            // Предполагается, что строки разделены запятой и пробелом, а элементы внутри строк разделены пробелом
            string[] rows = args[0].Split(',');

            int rowCount = rows.Length;
            int colCount = rows[0].Trim().Split(' ').Length;

            numbers = new int[rowCount, colCount];

            for (int i = 0; i < rowCount; i++)
            {
                string[] rowElements = rows[i].Trim().Split(' ');

                for (int j = 0; j < colCount; j++)
                {
                    if (int.TryParse(rowElements[j], out int result))
                    {
                        numbers[i, j] = result;
                    }
                    else
                    {
                        Console.WriteLine($"Error parsing element {rowElements[j]} to an integer.");
                        return;
                    }
                }
            }
        }
        else
        {
            // Если аргументов на входе нет, используем примерный массив

            numbers = new int[,] {
                {1, 2, 3},
                {1, 1, 0},
                {7, 8, 2},
                {9, 10, 11}
    };
        }
        UserInputToCompileForTest.PrintResult(numbers);
    }
}